<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ˆæ¥­åŠ‡æƒ…ç·¨æ’å·¥å…·</title>
    <style>
        :root {
            --primary: #2196F3;
            --danger: #f44336;
            --bg: #f8f9fa;
            --panel-width: 340px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* --- å·¦å´é¢æ¿ --- */
        #sidebar {
            width: var(--panel-width);
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            background: #fafafa;
        }

        .panel-header h2 {
            margin: 0;
            font-size: 1rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel-content {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }

        /* é€šç”¨è¼¸å…¥æ¨£å¼ */
        input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            margin-bottom: 5px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .btn-group input[type="text"] {
            margin-bottom: 0;
        }

        button {
            padding: 8px 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            opacity: 0.9;
        }

        button.add-btn {
            width: 100%;
            font-weight: bold;
            margin-top: 5px;
        }

        /* è§’è‰²åˆ—è¡¨ */
        #char-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .char-tag {
            display: inline-flex;
            /* è®“æ¨™ç±¤æ’åˆ—æ›´è‡ªç„¶ */
            align-items: center;
            /* å‚ç›´ç½®ä¸­ */
            gap: 6px;
            /* åœ“é»è·Ÿæ–‡å­—çš„è·é›¢ */
            padding: 5px 10px 5px 6px;
            /* èª¿æ•´å…§è·è®“è¦–è¦ºå¹³è¡¡ */
            border-radius: 20px;
            /* å®Œæ•´çš„åœ“è§’è† å›Š */
            background: #f0f0f0;
            /* ç¨å¾®äº®ä¸€é»çš„ç°è‰²èƒŒæ™¯ */
            border: 1px solid #ddd;
            /* å¾ˆç´°çš„ç°è‰²é‚Šæ¡†å¢åŠ è³ªæ„Ÿ */
            font-size: 0.9rem;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            /* é˜²æ­¢é€£é»æ™‚é¸å–åˆ°æ–‡å­— */
        }

        .char-tag:hover {
            background: #e4e4e4;
            /* æ»‘é¼ ç§»éå»ç¨å¾®è®Šæ·± */
            transform: translateY(-1px);
            /* å¾®å¾®æµ®èµ·çš„æ•ˆæœ */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .char-tag:active {
            transform: scale(0.95);
        }

        .char-color-box {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .delete-char-btn {
            font-size: 0.7rem;
            color: #999;
            margin-left: 5px;
            width: 16px;
            height: 16px;
            line-height: 14px;
            text-align: center;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        .delete-char-btn:hover {
            background: var(--danger);
            color: white;
        }

        /* åŠ‡æƒ…åˆ—è¡¨ */
        #plot-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .plot-card {
            background: white;
            border: 1px solid #ddd;
            border-left: 4px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            position: relative;
            transition: all 0.2s;
        }

        .plot-card:hover {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .plot-card.dragging {
            opacity: 0.5;
            background: #eef;
            border: 2px dashed #999;
        }

        .card-content {
            flex-grow: 1;
            font-size: 0.9rem;
            margin-right: 10px;
            line-height: 1.4;
            word-break: break-all;
        }

        .card-index {
            font-weight: bold;
            color: #bbb;
            font-size: 0.8rem;
            margin-right: 5px;
        }

        .delete-node-btn {
            color: #ddd;
            cursor: pointer;
            font-size: 1.1rem;
            line-height: 1;
        }

        .delete-node-btn:hover {
            color: var(--danger);
        }

        /* --- å³å´ç•«å¸ƒ --- */
        #workspace {
            flex-grow: 1;
            position: relative;
            background-image: radial-gradient(#ccc 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto;
            cursor: grab;
        }

        #workspace:active {
            cursor: grabbing;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .story-node {
            position: absolute;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: move;
            width: 160px;
            user-select: none;
        }

        .dot {
            width: 24px;
            height: 24px;
            background: #333;
            color: white;
            border: 3px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 5px;
        }

        .node-text {
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.85rem;
            text-align: center;
            white-space: pre-wrap;
            pointer-events: auto;
            /* å…è¨±æ–‡å­—å€åŸŸè¢«é›™æ“Š */
            max-width: 200px;
        }

        .highlight {
            font-weight: bold;
            padding: 0 1px;
        }

        /* æç¤ºå­— */
        .hint {
            font-size: 0.75rem;
            color: #888;
            margin-top: 5px;
            text-align: center;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <!-- å°‡é€™æ®µæ”¾åœ¨ #sidebar å…§çš„æœ€ä¸Šæ–¹ï¼Œæˆ–æ˜¯æœ€ä¸‹æ–¹ -->
        <div class="panel-header">
            <h2>æª”æ¡ˆå­˜å–</h2>
        </div>
        <div class="panel-content" style="flex-grow: 0; border-bottom: 1px solid #eee;">
            <div class="btn-group">
                <button onclick="downloadJSON()" style="background: #4CAF50;">â¬‡ ä¸‹è¼‰å­˜æª” (JSON)</button>
                <button onclick="document.getElementById('fileInput').click()" style="background: #FF9800;">â¬†
                    è¼‰å…¥å­˜æª”</button>
                <!-- éš±è—çš„æª”æ¡ˆä¸Šå‚³è¼¸å…¥æ¡† -->
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadJSON(this)">
            </div>
        </div>
        <!-- è§’è‰²å€å¡Š -->
        <div class="panel-header">
            <h2>è§’è‰²ç®¡ç†</h2>
        </div>
        <div class="panel-content" style="flex-grow: 0; border-bottom: 1px solid #eee;">
            <div class="btn-group">
                <input type="text" id="charName" placeholder="è§’è‰²åç¨±" onkeypress="handleCharEnter(event)">
                <input type="color" id="charColor" value="#ff5722" style="width: 50px; padding: 0;">
                <button onclick="addCharacter()">æ–°å¢</button>
            </div>
            <div id="char-list">
                <!-- è§’è‰²æ¨™ç±¤å‹•æ…‹ç”¢ç”Ÿ -->
            </div>
            <div class="hint">é»æ“Šæ¨™ç±¤å¯æ’å…¥åå­—ï¼Œé›™æ“Šå¯ç·¨è¼¯</div>
        </div>

        <!-- åŠ‡æƒ…å€å¡Š -->
        <div class="panel-header">
            <h2>åŠ‡æƒ…ç·¨æ’</h2>
        </div>
        <div class="panel-content" style="display: flex; flex-direction: column;">
            <div>
                <input type="text" id="plotContent" placeholder="è¼¸å…¥åŠ‡æƒ…å…§å®¹..." onkeypress="handlePlotEnter(event)">
                <button class="add-btn" onclick="addPlotNode()">ï¼‹ åŠ å…¥åŠ‡æƒ…ç¯€é»</button>
            </div>

            <div class="hint">æ‹–æ›³å¡ç‰‡æ’åºï¼Œé›™æ“Šå¡ç‰‡ç·¨è¼¯</div>

            <div id="plot-list" ondragover="handleDragOver(event)">
                <!-- åŠ‡æƒ…å¡ç‰‡å‹•æ…‹ç”¢ç”Ÿ -->
            </div>
        </div>
    </div>

    <div id="workspace">
        <svg id="svg-layer"></svg>
        <!-- ç•«å¸ƒç¯€é»å‹•æ…‹ç”¢ç”Ÿ -->
    </div>

    <script>
        // è³‡æ–™ç‹€æ…‹
        let characters = []; // [{id, name, color}]
        let nodes = [];      // [{id, text, x, y, el, listEl}]
        let nextCharId = 1;
        let nextNodeId = 1;

        const workspace = document.getElementById('workspace');
        const svgLayer = document.getElementById('svg-layer');
        const listContainer = document.getElementById('plot-list');
        const charListContainer = document.getElementById('char-list');
        const plotInput = document.getElementById('plotContent');

        // ==========================
        // è§’è‰²ç®¡ç†åŠŸèƒ½
        // ==========================

        function handleCharEnter(e) { if (e.key === 'Enter') addCharacter(); }

        function addCharacter() {
            const nameInput = document.getElementById('charName');
            const colorInput = document.getElementById('charColor');
            const name = nameInput.value.trim();

            if (!name) return;

            const charObj = {
                id: nextCharId++,
                name: name,
                color: colorInput.value
            };
            characters.push(charObj);

            renderCharacterTag(charObj);

            nameInput.value = '';
            refreshAllText();
        }

        function renderCharacterTag(charObj) {
            const tag = document.createElement('div');
            tag.className = 'char-tag';
            tag.dataset.id = charObj.id;


            tag.innerHTML = `
                <div class="char-color-box" style="background:${charObj.color}"></div>
                <span>${charObj.name}</span>
                <span class="delete-char-btn" title="åˆªé™¤">âœ•</span>
            `;

            // 1. é»æ“Šï¼šæ’å…¥åå­—åˆ°è¼¸å…¥æ¡†
            tag.addEventListener('click', (e) => {
                // å¦‚æœé»åˆ°åˆªé™¤éˆ•ï¼Œä¸åŸ·è¡Œæ’å…¥
                if (e.target.classList.contains('delete-char-btn')) return;

                // æ¸¸æ¨™ä½ç½®æ’å…¥ (ç°¡å–®ç‰ˆï¼šç›´æ¥åŠ åœ¨æœ€å¾Œ)
                plotInput.value += charObj.name;
                plotInput.focus();
            });

            // 2. é›™æ“Šï¼šç·¨è¼¯
            tag.addEventListener('dblclick', () => {
                const newName = prompt('ä¿®æ”¹è§’è‰²åç¨±:', charObj.name);
                if (newName !== null && newName.trim() !== '') {
                    charObj.name = newName.trim();
                    // é‡æ–°æ¸²æŸ“é€™å€‹ tag çš„æ–‡å­—
                    tag.querySelector('span').textContent = charObj.name;
                    refreshAllText();
                }
            });

            // 2.1 é»æ“Šé¡è‰²çƒï¼šä¿®æ”¹é¡è‰²
            const colorBox = tag.querySelector('.char-color-box');
            colorBox.addEventListener('click', (e) => {
                e.stopPropagation(); // é˜²æ­¢è§¸ç™¼æ’å…¥åå­—
                // å»ºç«‹ä¸€å€‹éš±è—çš„ input color ä¾†é¸è‰²
                const picker = document.createElement('input');
                picker.type = 'color';
                picker.value = charObj.color;
                picker.onchange = () => {
                    charObj.color = picker.value;
                    colorBox.style.background = charObj.color;
                    tag.style.borderLeftColor = charObj.color;
                    refreshAllText();
                };
                picker.click();
            });

            // 3. åˆªé™¤
            const delBtn = tag.querySelector('.delete-char-btn');
            delBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm(`ç¢ºå®šåˆªé™¤è§’è‰²ã€Œ${charObj.name}ã€å—ï¼Ÿ`)) {
                    characters = characters.filter(c => c.id !== charObj.id);
                    tag.remove();
                    refreshAllText();
                }
            });

            charListContainer.appendChild(tag);
        }

        // æ ¼å¼åŒ–æ–‡å­— (å°‡è§’è‰²åè®Šè‰²)
        function formatText(text) {
            let formatted = text;
            // ä¾ç…§åå­—é•·åº¦æ’åºï¼Œé¿å…ã€Œå°æ˜ã€å…ˆå–ä»£äº†ã€Œå°æ˜ç‹ã€
            const sortedChars = [...characters].sort((a, b) => b.name.length - a.name.length);

            sortedChars.forEach(char => {
                const regex = new RegExp(escapeRegExp(char.name), 'g');
                formatted = formatted.replace(regex, `<span class="highlight" style="color:${char.color}">${char.name}</span>`);
            });
            return formatted;
        }

        function refreshAllText() {
            nodes.forEach(node => {
                const html = formatText(node.text);
                node.el.querySelector('.node-text').innerHTML = html;
            });
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // ==========================
        // åŠ‡æƒ…ç¯€é»åŠŸèƒ½
        // ==========================

        function handlePlotEnter(e) { if (e.key === 'Enter') addPlotNode(); }

        function addPlotNode() {
            const text = plotInput.value.trim();
            if (!text) return;

            const id = `node-${nextNodeId++}`;

            // --- ä¿®æ”¹é–‹å§‹ï¼šåŸæœ¬è¤‡é›œçš„ XY è¨ˆç®—å…¨éƒ¨æ‹¿æ‰ï¼Œæš«æ™‚çµ¦ 0 å³å¯ ---
            let startX = 0;
            let startY = 0;
            // --- ä¿®æ”¹çµæŸ ---

            // å»ºç«‹ DOM (é€™éƒ¨åˆ†è·ŸåŸæœ¬ä¸€æ¨£)
            const nodeEl = document.createElement('div');
            nodeEl.className = 'story-node';
            nodeEl.innerHTML = `<div class="dot"></div><div class="node-text"></div>`;
            workspace.appendChild(nodeEl);

            const listEl = document.createElement('div');
            listEl.className = 'plot-card';
            listEl.draggable = true;
            listEl.dataset.nodeId = id;
            listEl.innerHTML = `
                <span class="card-index"></span>
                <div class="card-content">${text}</div>
                <div class="delete-node-btn" title="åˆªé™¤">âœ•</div>
            `;
            listContainer.appendChild(listEl);

            const nodeData = { id, text, x: startX, y: startY, el: nodeEl, listEl: listEl };
            nodes.push(nodeData);

            updateNodeVisuals(nodeData, nodes.length);
            bindNodeEvents(nodeData);

            plotInput.value = '';
            listContainer.scrollTop = listContainer.scrollHeight;

            // ğŸ”¥ é—œéµï¼šæ–°å¢å®Œå¾Œï¼Œå‘¼å«è‡ªå‹•æ’ç‰ˆï¼Œå®ƒæœƒå¹«ä½ æŠŠæ‰€æœ‰é»ï¼ˆåŒ…å«å‰›æ–°å¢çš„ï¼‰æ’æ•´é½Š
            autoLayout();
        }

        function updateNodeVisuals(node, index) {
            // æ›´æ–°ç·¨è™Ÿ
            node.el.querySelector('.dot').textContent = index;
            node.listEl.querySelector('.card-index').textContent = `#${index}`;
            // æ›´æ–°æ–‡å­—èˆ‡é¡è‰²
            node.el.querySelector('.node-text').innerHTML = formatText(node.text);
            node.listEl.querySelector('.card-content').textContent = node.text;
        }

        function bindNodeEvents(node) {
            // --- åˆ—è¡¨å¡ç‰‡äº‹ä»¶ ---

            // é›™æ“Šç·¨è¼¯
            node.listEl.addEventListener('dblclick', () => editNodeContent(node));

            // åˆªé™¤æŒ‰éˆ•
            node.listEl.querySelector('.delete-node-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteNode(node);
            });

            // æ‹–æ›³æ’åº
            node.listEl.addEventListener('dragstart', () => node.listEl.classList.add('dragging'));
            node.listEl.addEventListener('dragend', () => {
                node.listEl.classList.remove('dragging');
                reorderNodes();
            });

            // --- ç•«å¸ƒç¯€é»äº‹ä»¶ ---

            // é›™æ“Šç•«å¸ƒä¸Šçš„æ–‡å­—ä¹Ÿå¯ä»¥ç·¨è¼¯
            node.el.querySelector('.node-text').addEventListener('dblclick', (e) => {
                e.stopPropagation(); // é¿å…è§¸ç™¼ç•«å¸ƒçš„é»æ“Š
                editNodeContent(node);
            });

            // æ‹–æ›³ä½ç½®
            makeDraggable(node);
        }

        function editNodeContent(node) {
            const newText = prompt("ç·¨è¼¯åŠ‡æƒ…å…§å®¹:", node.text);
            if (newText !== null && newText.trim() !== "") {
                node.text = newText.trim();
                // é‡æ–°æ¸²æŸ“è©²ç¯€é»çš„æ–‡å­—
                node.el.querySelector('.node-text').innerHTML = formatText(node.text);
                node.listEl.querySelector('.card-content').textContent = node.text;
            }
        }

        function deleteNode(targetNode) {
            if (!confirm("ç¢ºå®šåˆªé™¤æ­¤åŠ‡æƒ…é»ï¼Ÿ")) return;

            // 1. ç§»é™¤ DOM
            targetNode.el.remove();
            targetNode.listEl.remove();

            // 2. å¾é™£åˆ—ç§»é™¤
            nodes = nodes.filter(n => n.id !== targetNode.id);

            // 3. é‡æ–°ç·¨è™Ÿ (#1, #2...)
            nodes.forEach((n, index) => {
                n.el.querySelector('.dot').textContent = index + 1;
                n.listEl.querySelector('.card-index').textContent = `#${index + 1}`;
            });

            // 4. é‡ç•«ç·š
            drawLines();
        }

        // ==========================
        // æ‹–æ›³æ’åºèˆ‡é€£ç·šé‚è¼¯
        // ==========================

        function handleDragOver(e) {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            const container = listContainer;

            // æ‰¾å‡ºæœ€è¿‘çš„å…ƒç´ 
            const siblings = [...container.querySelectorAll('.plot-card:not(.dragging)')];
            const nextSibling = siblings.find(sibling => {
                return e.clientY <= sibling.getBoundingClientRect().top + sibling.getBoundingClientRect().height / 2;
            });

            container.insertBefore(draggingItem, nextSibling);
        }

        function reorderNodes() {
            const newOrderIds = [...listContainer.querySelectorAll('.plot-card')].map(el => el.dataset.nodeId);
            const nodeMap = new Map(nodes.map(n => [n.id, n]));

            nodes = newOrderIds.map(id => nodeMap.get(id));

            nodes.forEach((n, index) => {
                n.el.querySelector('.dot').textContent = index + 1;
                n.listEl.querySelector('.card-index').textContent = `#${index + 1}`;
            });

            // ğŸ”¥ ä¿®æ”¹é€™è£¡ï¼šåŸæœ¬æ˜¯ drawLines()ï¼Œç¾åœ¨æ”¹æˆ autoLayout()
            // é€™æ¨£æ’åºæ”¹è®Šæ™‚ï¼Œæ ¼å­ä½ç½®ä¹Ÿæœƒè·Ÿè‘—é‡æ–°æ´—ç‰Œ
            autoLayout();
        }

        function drawLines() {
            // 1. è‡ªå‹•æ’å¤§ç•«å¸ƒ (ä¿ç•™ä¸Šä¸€ç‰ˆçš„åŠŸèƒ½)
            let maxX = workspace.clientWidth;
            let maxY = workspace.clientHeight;
            nodes.forEach(node => {
                if (node.x + 300 > maxX) maxX = node.x + 300;
                if (node.y + 300 > maxY) maxY = node.y + 300;
            });
            svgLayer.style.width = maxX + 'px';
            svgLayer.style.height = maxY + 'px';

            // 2. æ¸…é™¤èˆŠç·šä¸¦å®šç¾©ç®­é ­
            svgLayer.innerHTML = '';
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `<marker id="arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#999"/></marker>`;
            svgLayer.appendChild(defs);

            if (nodes.length < 2) return;

            // 3. é–‹å§‹ç¹ªè£½æŠ˜ç·šè·¯å¾‘
            for (let i = 0; i < nodes.length - 1; i++) {
                const curr = nodes[i];
                const next = nodes[i + 1];

                // åº§æ¨™æ ¡æ­£ï¼šå°æº–åœ“é»ä¸­å¿ƒ
                const x1 = curr.x + 80;
                const y1 = curr.y + 12;
                const x2 = next.x + 80;
                const y2 = next.y + 12;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // åˆ¤æ–·æ˜¯å¦æ›è¡Œ (åˆ©ç”¨ Y è»¸çš„é«˜åº¦å·®)
                const isNextRow = (next.y - curr.y) > 100; // å¦‚æœé«˜åº¦å·®è¶…é 100px è¦–ç‚ºæ›è¡Œ

                let d = '';
                if (isNextRow) {
                    // --- æŠ˜ç·šé‚è¼¯ (90åº¦è½‰å½) ---
                    // è¨ˆç®—ä¸­é–“çš„è½‰æŠ˜é«˜åº¦ (å…©è¡Œä¹‹é–“)
                    const midY = curr.y + (next.y - curr.y) / 2 + 12;

                    // è·¯å¾‘æŒ‡ä»¤è§£é‡‹ï¼š
                    // M x1 y1 : ç§»å‹•åˆ°èµ·é»
                    // V midY  : å‚ç›´ç•«ç·š (Vertical) åˆ°ä¸­é–“é«˜åº¦
                    // H x2    : æ°´å¹³ç•«ç·š (Horizontal) åˆ°ç›®æ¨™çš„ X ä½ç½®
                    // V y2    : å‚ç›´ç•«ç·š (Vertical) åˆ°çµ‚é»
                    d = `M ${x1} ${y1} V ${midY} H ${x2} V ${y2}`;
                } else {
                    // --- ç›´ç·šé‚è¼¯ (åŒä¸€è¡Œ) ---
                    d = `M ${x1} ${y1} L ${x2} ${y2}`;
                }

                path.setAttribute('d', d);
                path.setAttribute('stroke', '#999');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-dasharray', '5,5');
                path.setAttribute('fill', 'none'); // é‡è¦ï¼šè·¯å¾‘ä¸è¦å¡«è‰²
                path.setAttribute('marker-end', 'url(#arrow)');

                svgLayer.appendChild(path);
            }
        }

        function makeDraggable(node) {
            const el = node.el;
            let isDragging = false;
            let startX, startY, initL, initT;

            el.addEventListener('mousedown', (e) => {
                // å¦‚æœé»åˆ°æ–‡å­—æ¡†ï¼Œä¸è§¸ç™¼æ‹–æ›³ï¼ˆè®“é›™æ“Šæ–‡å­—æ¯”è¼ƒå®¹æ˜“åˆ¤å®šï¼‰
                if (e.target.classList.contains('node-text')) return;

                isDragging = true;
                startX = e.clientX; startY = e.clientY;
                initL = el.offsetLeft; initT = el.offsetTop;
                el.style.zIndex = 100;
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const newX = initL + (e.clientX - startX);
                const newY = initT + (e.clientY - startY);

                el.style.left = newX + 'px';
                el.style.top = newY + 'px';

                node.x = newX; node.y = newY;
                drawLines();
            });

            window.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    el.style.zIndex = 2;
                }
            });
        }

        // ==========================
        // æª”æ¡ˆå­˜å–åŠŸèƒ½ (Export / Import)
        // ==========================

        function downloadJSON() {
            // 1. æ•´ç†è¦å„²å­˜çš„è³‡æ–™
            // æ³¨æ„ï¼šnodes é™£åˆ—è£¡é¢åŸæœ¬åŒ…å« DOM ç‰©ä»¶ (el, listEl)ï¼Œé€™äº›ä¸èƒ½å­˜é€² JSON
            // æ‰€ä»¥æˆ‘å€‘è¦ map å‡ºä¸€å€‹ä¹¾æ·¨çš„è³‡æ–™é™£åˆ—
            const cleanNodes = nodes.map(n => ({
                id: n.id,
                text: n.text,
                x: n.x,
                y: n.y
            }));

            const dataToSave = {
                characters: characters,
                nodes: cleanNodes,
                nextCharId: nextCharId,
                nextNodeId: nextNodeId
            };

            // 2. è½‰æˆ Blob ä¸¦ä¸‹è¼‰
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToSave));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "story_backup_" + new Date().toISOString().slice(0, 10) + ".json");
            document.body.appendChild(downloadAnchorNode); // Firefox éœ€è¦é€™ä¸€è¡Œ
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function loadJSON(inputElement) {
            const file = inputElement.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);
                    restoreData(data);
                } catch (err) {
                    alert("è®€å–æª”æ¡ˆå¤±æ•—ï¼Œæ ¼å¼å¯èƒ½éŒ¯èª¤ã€‚\n" + err);
                }
            };
            reader.readAsText(file);

            // æ¸…ç©º input è®“åŒå€‹æª”æ¡ˆå¯ä»¥å†æ¬¡è¢«é¸å–
            inputElement.value = '';
        }

        function restoreData(data) {
            if (!data.characters || !data.nodes) {
                alert("æª”æ¡ˆç¼ºå°‘å¿…è¦è³‡æ–™ (characters æˆ– nodes)");
                return;
            }

            // 1. æ¸…ç©ºç¾æœ‰ç•«é¢èˆ‡è³‡æ–™
            characters = [];
            nodes = [];
            charListContainer.innerHTML = '';
            listContainer.innerHTML = '';

            // ä¿ç•™ SVG å±¤ï¼Œæ¸…ç©ºå…¶ä»– DOM
            workspace.innerHTML = '';
            workspace.appendChild(svgLayer);
            svgLayer.innerHTML = ''; // æ¸…ç©ºç·šæ¢

            // 2. é‚„åŸè®Šæ•¸è¨ˆæ•¸å™¨ (å¦‚æœæª”æ¡ˆè£¡æ²’æœ‰ï¼Œå°±ç”¨é è¨­å€¼)
            nextCharId = data.nextCharId || 1;
            nextNodeId = data.nextNodeId || 1;

            // 3. é‚„åŸè§’è‰²
            data.characters.forEach(charObj => {
                characters.push(charObj);
                renderCharacterTag(charObj);
            });

            // 4. é‚„åŸåŠ‡æƒ…ç¯€é»
            data.nodes.forEach((nodeData, index) => {
                // é‡å»º DOM çµæ§‹ (é‚è¼¯åƒè€ƒåŸæœ¬çš„ addPlotNodeï¼Œä½†ä½¿ç”¨æŒ‡å®šçš„ xy å’Œ id)
                reconstructNodeDOM(nodeData, index + 1);
            });

            // 5. æœ€å¾Œé‡ç•«ç·š
            autoLayout();
        }

        // é€™æ˜¯å°ˆé–€ç”¨ä¾†ã€Œä¾ç…§è³‡æ–™é‡å»º DOMã€çš„å‡½å¼
        function reconstructNodeDOM(nodeData, index) {
            // å»ºç«‹ç•«å¸ƒç¯€é»
            const nodeEl = document.createElement('div');
            nodeEl.className = 'story-node';
            nodeEl.style.left = nodeData.x + 'px';
            nodeEl.style.top = nodeData.y + 'px';
            nodeEl.innerHTML = `
        <div class="dot">${index}</div>
        <div class="node-text">${formatText(nodeData.text)}</div>
    `;
            workspace.appendChild(nodeEl);

            // å»ºç«‹åˆ—è¡¨å¡ç‰‡
            const listEl = document.createElement('div');
            listEl.className = 'plot-card';
            listEl.draggable = true;
            listEl.dataset.nodeId = nodeData.id;
            listEl.innerHTML = `
        <span class="card-index">#${index}</span>
        <div class="card-content">${nodeData.text}</div>
        <div class="delete-node-btn" title="åˆªé™¤">âœ•</div>
    `;
            listContainer.appendChild(listEl);

            // é‡çµ„å®Œæ•´çš„ node ç‰©ä»¶
            const newNode = {
                id: nodeData.id,
                text: nodeData.text,
                x: nodeData.x,
                y: nodeData.y,
                el: nodeEl,
                listEl: listEl
            };

            nodes.push(newNode);

            // é‡æ–°ç¶å®šæ‰€æœ‰äº‹ä»¶ (æ‹–æ›³ã€ç·¨è¼¯ã€åˆªé™¤)
            bindNodeEvents(newNode);
        }

        // ==========================
        // è‡ªå‹•æ’ç‰ˆç³»çµ±
        // ==========================

        function autoLayout() {
            const xStart = 50;       // èµ·å§‹ X
            const yStart = 100;      // èµ·å§‹ Y
            const xStep = 180;       // å·¦å³æ ¼å­çš„é–“è· (åŸæœ¬å¤§ç´„æ˜¯180)
            const yStep = 250;       // ğŸ”¥ ä¸Šä¸‹æ›è¡Œçš„é–“è· (é€™è£¡åŠ å¤§ï¼)
            const maxWidth = workspace.clientWidth - 200; // ç•«å¸ƒå³é‚Šç•Œ

            let currentX = xStart;
            let currentY = yStart;

            nodes.forEach((node) => {
                // 1. å¼·åˆ¶æ›´æ–°ç¯€é»çš„åº§æ¨™è³‡æ–™
                node.x = currentX;
                node.y = currentY;

                // 2. æ›´æ–°ç•«é¢ä¸Šçš„åœ“é»ä½ç½®
                node.el.style.left = currentX + 'px';
                node.el.style.top = currentY + 'px';

                // 3. è¨ˆç®—ä¸‹ä¸€å€‹é»çš„ä½ç½®
                currentX += xStep;

                // 4. åˆ¤æ–·æ˜¯å¦éœ€è¦æ›è¡Œ
                if (currentX > maxWidth) {
                    currentX = xStart; // å›åˆ°æœ€å·¦é‚Š
                    currentY += yStep; // å¾€ä¸‹è·³ä¸€è¡Œ
                }
            });

            // 5. æ’ç‰ˆå®Œå¾Œé‡ç•«é€£ç·šï¼Œç¢ºä¿ç·šæ¢æ­£ç¢º
            drawLines();
        }
    </script>
</body>

</html>